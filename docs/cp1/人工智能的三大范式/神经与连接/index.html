<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-cp1/人工智能的三大范式/神经与连接" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">神经与连接 | 智能的觉醒</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="神经与连接 | 智能的觉醒"><meta data-rh="true" name="description" content="人工智能领域的源起，呈现出两条截然不同却又在未来交汇的技术路线。其中一条是自顶向下的符号主义，它将智能的核心归于逻辑与推理，试图在计算机内部构建一个由严谨规则驱动的知识王国。而另一条路线则显得更为朴素和原始，它放弃了对高级心智活动的直接模拟，转而向构成智能的生物学基础——大脑——寻求灵感。这条自下而上的道路，即是连接主义，其最初的雄心，便是从模拟最基本的神经元结构开始，期待智能能够从简单的单元交互中“涌现”而出。"><meta data-rh="true" property="og:description" content="人工智能领域的源起，呈现出两条截然不同却又在未来交汇的技术路线。其中一条是自顶向下的符号主义，它将智能的核心归于逻辑与推理，试图在计算机内部构建一个由严谨规则驱动的知识王国。而另一条路线则显得更为朴素和原始，它放弃了对高级心智活动的直接模拟，转而向构成智能的生物学基础——大脑——寻求灵感。这条自下而上的道路，即是连接主义，其最初的雄心，便是从模拟最基本的神经元结构开始，期待智能能够从简单的单元交互中“涌现”而出。"><link data-rh="true" rel="icon" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接"><link data-rh="true" rel="alternate" href="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/assets/css/styles.cd147f59.css">
<script src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/assets/js/runtime~main.31f41e4b.js" defer="defer"></script>
<script src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/assets/js/main.4dee548e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/"><div class="navbar__logo"><img src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/logo.svg" alt="My Book Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/logo.svg" alt="My Book Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">主页</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/本书导览">Read Book</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/本书导览">本书导览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/intro">前言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第一章智能的拂晓">第一章：智能的拂晓</a><button aria-label="折叠侧边栏分类 &#x27;第一章：智能的拂晓&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/前言">前言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/人工智能的三大范式">人工智能的三大范式</a><button aria-label="折叠侧边栏分类 &#x27;人工智能的三大范式&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/符号与逻辑">符号与逻辑</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接">神经与连接</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化">计算与进化</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第二章ai江湖-人物与格局">第二章：AI江湖-人物与格局</a><button aria-label="展开侧边栏分类 &#x27;第二章：AI江湖-人物与格局&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第一章智能的拂晓"><span itemprop="name">第一章：智能的拂晓</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/人工智能的三大范式"><span itemprop="name">人工智能的三大范式</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">神经与连接</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>神经与连接</h1></header><p>人工智能领域的源起，呈现出两条截然不同却又在未来交汇的技术路线。其中一条是自顶向下的符号主义，它将智能的核心归于逻辑与推理，试图在计算机内部构建一个由严谨规则驱动的知识王国。而另一条路线则显得更为朴素和原始，它放弃了对高级心智活动的直接模拟，转而向构成智能的生物学基础——大脑——寻求灵感。这条自下而上的道路，即是连接主义，其最初的雄心，便是从模拟最基本的神经元结构开始，期待智能能够从简单的单元交互中“涌现”而出。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="当机器开始模仿神经元">当机器开始模仿神经元<a href="#当机器开始模仿神经元" class="hash-link" aria-label="当机器开始模仿神经元的直接链接" title="当机器开始模仿神经元的直接链接">​</a></h2>
<p>1943年，神经生理学家沃伦·麦卡洛克（Warren McCulloch）和数学家沃尔特·皮茨（Walter Pitts）合作发表了开创性论文《神经活动中内在思想的逻辑演算》（A Logical Calculus of the Ideas Immanent in Nervous Activity）。他们首次提出了一个极其简化的神经元数学模型，后被称为“M-P神经元模型”。该模型将神经元抽象为一个二元决策单元：它接收来自其他多个神经元的输入信号，如果这些信号的加权总和超过了神经元自身的内部阈值，它便被“激活”并输出一个“1”（代表兴奋）；否则，它就输出“0”（代表抑制）。</p>
<p>麦卡洛克和皮茨证明，通过将这些简单的逻辑单元以特定方式组合，可以实现任何布尔逻辑功能（与、或、非），这意味着一个由M-P神经元组成的网络在理论上具备了执行复杂计算的潜力。然而，M-P模型有一个根本性的局限：它是一个静态模型。网络结构和连接权重需要由人类专家预先设计和设定，它自身不具备从经验中学习和调整的能力。这就像是制造了一台计算器，虽然能进行运算，但其功能在出厂时已被完全固化。</p>
<p>真正的突破发生在1957年，由康奈尔航空实验室（Cornell Aeronautical Laboratory）的心理学家弗兰克·罗森布拉特（Frank Rosenblatt）完成。罗森布拉特不仅是一位科学家，更是一位极富远见和感染力的倡导者。他深受赫布理论（Hebb&#x27;s Rule）中“共同激活的神经元之间连接会得到加强”这一思想的启发，决心创造一个能够自动学习的神经元模型。其成果，便是大名鼎鼎的“感知机”（Perceptron）。</p>
<p>感知机继承了M-P模型的基本结构，但引入了一个革命性的概念：学习算法。罗森布拉特的感知机模型可以被形式化地描述。假设一个感知机接收 n 个输入，x1​,x2​,…,xn​，每个输入都对应一个可调整的权重 w1​,w2​,…,wn​。模型的输出 y 由一个带有阈值 θ 的阶跃函数（Step Function）决定：</p>
<p>y=10​if ∑i=1n​wi​xi​≥θotherwise​</p>
<p>这个公式描述了感知机的决策过程，但其精髓在于感知机学习规则（Perceptron Learning Rule）。罗森布拉特设计了一个简单的迭代过程来自动更新权重。首先，用一组随机值初始化所有权重。然后，将一个训练样本输入感知机，观察其输出。如果输出是正确的，则权重保持不变；如果输出是错误的，则对权重进行调整。具体的调整规则是：</p>
<ul>
<li>若感知机输出为0，但正确标签为1（漏报），则将所有对应输入为1的权重 wi​ 增加一个固定的学习率 α：wi​←wi​+αxi​。</li>
<li>若感知机输出为1，但正确标签为0（误报），则将所有对应输入为1的权重 wi​ 减小一个固定的学习率 α：wi​←wi​−αxi​。</li>
</ul>
<p>这个过程反复进行，直到感知机能够正确分类训练集中的所有样本。罗森布拉特在数学上证明了著名的感知机收敛定理：只要训练数据是线性可分的（即存在一个超平面能将不同类别的样本点完全分开），那么感知机学习算法保证能在有限次的迭代后找到一组可以将所有样本正确分类的权重。</p>
<p>为了验证和展示这一理论，罗森布拉特在1958年建造了物理硬件——Mark I 感知机。这台机器在当时堪称工程奇迹，它的“眼睛”是一个由400个光电管组成的20x20阵列，用于捕捉图像。输入信号通过一团看似杂乱的电线连接到一组“关联单元”（A-unit），这些单元的权重由一系列与电动机相连的电位器物理实现。当机器进行学习时，电动机便会根据学习规则自动旋转电位器旋钮，从而调整权重值。</p>
<p>Mark I 感知机的公开演示引发了媒体的狂热追捧。1958年7月，《纽约时报》发表了一篇极具影响力的报道，标题激动人心，并宣称美国海军“展示了一台能够行走、说话、看、写、自我复制并意识到自身存在的电子计算机的雏形”。这种近乎科幻的描述极大地激发了公众的想象力，也吸引了军方的浓厚兴趣。在冷战的背景下，美国海军研究办公室（Office of Naval Research）为罗森布拉特的研究提供了大量资金，期望这项技术未来能应用于图像识别、目标跟踪等军事领域。</p>
<p>感知机的诞生，标志着连接主义从纯粹的理论猜想迈向了工程实践。它首次证明，一个简单的、受生物启发的计算单元，可以通过一个明确的算法从数据中自动学习。这把“火”点燃了人们对于构建“会思考的机器”的希望，也让连接主义作为人工智能的一股新生力量，正式登上了历史舞台。然而，这股初生的热情，即将面临来自另一主流阵营的严峻审视与致命挑战。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="明斯基的致命一击与漫长的ai之冬">明斯基的致命一击与漫长的AI之冬<a href="#明斯基的致命一击与漫长的ai之冬" class="hash-link" aria-label="明斯基的致命一击与漫长的AI之冬的直接链接" title="明斯基的致命一击与漫长的AI之冬的直接链接">​</a></h2>
<p>在感知机声名鹊起之时，人工智能研究领域的主流范式是符号主义。其领军人物，如卡内基梅隆大学的艾伦·纽厄尔（Allen Newell）和赫伯特·西蒙（Herbert Simon），以及麻省理工学院（MIT）的马文·明斯基（Marvin Minsky）和约翰·麦卡锡（John McCarthy），都坚信智能的本质是基于符号的逻辑运算和启发式搜索。他们开发的“逻辑理论家”（Logic Theorist）和“通用问题求解器”（General Problem Solver）等程序，通过模拟人类的推理过程在定理证明和问题求解上取得了初步成功。</p>
<p>在这些符号主义的先驱看来，罗森布拉特的感知机是一种“非主流”的、缺乏理论深度的“黑箱”。他们对其铺天盖地的宣传和过高的期望抱持着深深的怀疑。这场理念之争最终在1969年以一种极具毁灭性的方式爆发。明斯基，这位当时AI领域的权威人物，与同在MIT的西摩尔·派普特（Seymour Papert）合著出版了《感知机》（Perceptrons）一书。这本书并非一篇简单的评论文章，而是一部运用严谨数学工具对感知机模型进行深度剖析的学术专著。</p>
<p>该书的核心论点直指感知机的根本局限性：线性可分性（Linear Separability）。明斯基和派普特系统地证明，一个单层感知机（即罗森布拉特模型）本质上只是在输入空间中寻找一个线性决策边界——在二维空间中是一条直线，在三维空间中是一个平面，在高维空间中则是一个超平面。它只能解决那些可以用一个这样的超平面就能将正负样本完全分离开来的问题。</p>
<p>为了将这个抽象的数学概念以最清晰、最有力的方式呈现给世人，他们找到了一个绝佳的“反例”——异或（XOR）问题。</p>
<p>异或是一个基本的逻辑运算，其规则是：当两个输入不同时，输出为真（1）；当两个输入相同时，输出为假（0）。我们可以将其表示为真值表：</p>
<table><thead><tr><th style="text-align:center">输入1 (x1)</th><th style="text-align:center">输入2 (x2)</th><th style="text-align:center">输出 (y)</th></tr></thead><tbody><tr><td style="text-align:center">0</td><td style="text-align:center">0</td><td style="text-align:center">0</td></tr><tr><td style="text-align:center">0</td><td style="text-align:center">1</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">0</td><td style="text-align:center">1</td></tr><tr><td style="text-align:center">1</td><td style="text-align:center">1</td><td style="text-align:center">0</td></tr></tbody></table>
<p>当我们将这四个点绘制在二维坐标系上时，(0,0)和(1,1)是“假”类，(0,1)和(1,0)是“真”类。通过简单的观察就能发现，我们无法画出一条直线，将“真”类点和“假”类点完美地分在直线两侧。任何试图这么做的直线，都必然会错误地分类至少一个点。</p>
<p>《感知机》一书以无可辩驳的数学逻辑证明，单层感知机模型在结构上无法解决XOR这类线性不可分问题。书中还分析了其他一些感知机无法解决的问题，如判断一个图形是否“连通”。这无异于宣告了罗森布拉特模型的“死刑”。</p>
<p>更为致命的是，明斯基和派普特在书中对多层感知机的潜力也表达了悲观。他们承认，通过堆叠多个神经元层，理论上可以构建出能解决XOR问题的网络。但是，他们紧接着指出，当时没有任何已知的、有效的算法能够训练这样一个多层网络。感知机学习规则只适用于单层，如何为隐藏在网络中间的“隐层”神经元分配误差和调整权重，是一个悬而未决的难题（即后来的“信用分配问题”）。他们断言，这类问题在计算上可能是“不可解的”（intractable）。</p>
<p>这本书的影响是立竿见影且极具破坏性的。作为AI领域的权威著作，它成为了资助机构评估项目价值的重要参考。美国国防部高级研究计划局（ARPA，即后来的DARPA）是当时AI研究最主要的资金来源，其决策者们读完这本书后得出的结论是：连接主义路线的潜力有限，其所宣称的宏伟目标在数学上被证明是难以企及的。于是，流向神经网络研究的资金几乎被完全切断，资源被集中到了看似更有前景的符号主义AI项目上。</p>
<p>学术界也迅速转向。研究生们不再愿意选择连接主义作为研究方向，相关的学术会议和期刊论文数量锐减。罗森布拉特本人于1971年不幸英年早逝，连接主义阵营失去了一位最重要的旗手。整个领域迅速冷却，进入了长达十余年的“AI之冬”（AI Winter）。</p>
<p>明斯基和派普特的批评，从纯粹的科学角度看是严谨且正确的。他们的确精准地指出了当时感知机模型的理论边界。然而，其著作的巨大影响力，加上当时整个学术和资助环境的倾向，客观上将一个充满潜力的研究领域打入了冷宫。那颗刚刚萌芽的“智能种子”，连同那些关于自学习、自组织的梦想，一并被冰封在了数学的严酷逻辑和现实的资金寒冬之中。只有少数坚守者，仍在漫长的冬日里，默默地寻找着那把能够解开“信用分配”难题的钥匙，等待着春天的到来。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="一群顽固派如何教机器知错能改">一群“顽固派”如何教机器“知错能改”<a href="#一群顽固派如何教机器知错能改" class="hash-link" aria-label="一群“顽固派”如何教机器“知错能改”的直接链接" title="一群“顽固派”如何教机器“知错能改”的直接链接">​</a></h2>
<p>历史的有趣之处在于，总有一些“顽固派”，他们要么是没读过“判决书”的愣头青，要么是读过之后仍旧相信地平线尽头另有风景的“疯子”。正是这群在寒冬中围炉取暖的学者，最终找到了让机器“知错能改”的关键钥匙，它的名字叫做“反向传播”（Backpropagation）。</p>
<p>这把钥匙的第一个铸造者是一位名叫保罗·韦尔博斯（Paul Werbos）的年轻人。1974年，当大多数人还在为明斯基的结论而沮丧时，韦尔博斯正在哈佛大学攻读他的博士学位。他的论文题目听起来与当时主流的AI研究格格不入——《超越回归：行为科学中预测与分析的新工具》（<em>Beyond Regression: New Tools for Prediction and Analysis in the Behavioral Sciences</em>）。韦尔博斯着迷于一个更普适的问题：我们如何为一个复杂的非线性系统——无论是人类社会，还是一个多层神经网络——建立一个精准的模型，并让它有效地学习？</p>
<p>韦尔博斯从控制论和系统优化的思想中汲取灵感，他意识到，如果你想让一个系统的输出逼近期望的目标，你需要知道每一个参数的改变对最终结果有多大影响。在数学上，这就是“梯度”的概念。对于一个由多个函数层层嵌套的复杂系统（比如一个多层神经网络），计算这个梯度异常困难。韦尔bo斯创造性地应用了链式法则，提出了一种高效计算梯度的方法：首先，计算输出层的误差；然后，将这个误差信号像回声一样，从后向前逐层传播，每经过一层，就根据这一层的连接权重计算出前一层的“误差贡献”；最后，根据每一层计算出的误差梯度，微调连接权重。</p>
<p>这个过程，就是反向传播的核心思想。它优雅地解决了“信用分配”（Credit Assignment）问题——在复杂的网络中，如何确定每一个神经元（或者说，每一个权重）对最终的错误负有多大责任。韦尔博斯在他的博士论文中完整地阐述了这一算法。然而，这颗足以融化整个AI之冬的火种，却在当时被扔进了一堆无人问津的故纸堆里。韦尔博斯自己也感叹，他感觉就像一个在荒野中布道的先知，听众寥寥。他的工作在随后的近十年里几乎无人知晓。</p>
<p>历史的接力棒传到了一群聚集在加州大学圣迭戈分校（UCSD）的心理学家和认知科学家手中。他们组成了一个后来声名显赫的研究小组——并行分布式处理研究组（Parallel Distributed Processing Research Group, PDP Group）。这个小组的核心人物包括大卫·鲁梅尔哈特（David Rumelhart）和詹姆斯·麦克利兰（James McClelland）。与主流AI试图用逻辑符号模拟高级认知功能不同，他们相信，智能蕴藏在大量简单处理单元（神经元）的并行交互之中，这更接近大脑的真实运作方式。</p>
<p>在这个小组里，还有一位从英国远道而来的年轻研究员，他就是后来被誉为“深度学习教父”之一的杰弗里·辛顿（Geoffrey Hinton）。辛顿出身于一个显赫的科学世家（他的曾曾祖父是逻辑学家乔治·布尔），骨子里就有一种叛逆和对“不可能”的挑战精神。他对神经网络的信念近乎偏执，即便在AI的寒冬期，他依然坚定地认为这是通往真正智能的正确道路。</p>
<p>80年代初，辛顿、鲁梅尔哈特和他们的同事罗纳德·威廉姆斯（Ronald Williams）开始重新审视多层网络的学习问题。他们并不知道韦尔博斯的早期工作，而是独立地（几乎是同时，法国的杨立昆（Yann LeCun）也在独立研究类似的想法）重新发现了反向传播算法。他们的幸运之处在于，他们不仅仅是发现了算法，更重要的是，他们将这个算法置于一个宏大的理论框架之下，并用一系列极具说服力的实验证明了它的威力。</p>
<p>1986年，他们在顶级科学期刊《自然》（<em>Nature</em>）上发表了那篇划时代的论文——《通过反向传播误差学习表征》（<em>Learning Representations by Back-Propagating Errors</em>）。这篇文章如同一声惊雷，宣告了连接主义的正式回归。他们清晰地展示了，一个包含“隐藏层”（Hidden Layers）的多层网络，在经过反向传播算法的训练后，能够自动学习到数据中复杂的、抽象的内部表征（Internal Representations）。这正是当年明斯基认为感知器无法做到的事情。</p>
<p>让我们用一个简单的例子来理解这个突破的本质。假设我们要训练一个网络识别图片中的猫。在网络的输入层，我们输入图片的所有像素。在输出层，我们希望只有一个神经元被激活，代表“猫”。中间的隐藏层，在训练开始时是随机的。当第一张猫的图片输入后，网络的输出可能是“狗”或者“汽车”，总之是错误的。这时，反向传播就开始工作了：</p>
<ol>
<li><strong>计算误差</strong>：输出层的神经元会说：“错了！目标是1（猫），我的输出却是0.1，误差是0.9。”</li>
<li><strong>反向传播</strong>：这个误差信号被传回给连接到输出层的最后一个隐藏层。算法会计算，这一层的每个神经元对这个0.9的误差贡献了多少。比如，A神经元可能贡献了0.6，B神经元贡献了0.3。</li>
<li><strong>权重调整</strong>：接着，算法会告诉A神经元：“你的激活导致了大部分错误，下次遇到类似输入，你的激活应该弱一点。”同时告诉B神经元：“你也错了，但责任小一些。”这个“告诉”的过程，就是通过微调它们与输出层之间的连接权重来实现的。如果一个连接对错误结果是正贡献，就减小它的权重；如果是负贡献，就增大它。</li>
<li><strong>逐层回溯</strong>：这个过程继续向后传播，直到网络的第一个隐藏层。每一层的权重都会根据它们对最终误差的“责任”大小进行调整。</li>
</ol>
<p>这个过程就像一个庞大的公司在项目失败后进行复盘。CEO（输出层）发现利润没达标（误差），他不会直接解雇所有员工，而是把压力传递给各部门总监（最后一个隐藏层）。总监们再根据业绩（对误差的贡献），评估手下的项目经理（更前一层的神经元），最终将责任落实到每个具体的员工（连接权重），并调整他们的奖金（权重值）。</p>
<p>一遍又一遍地重复这个“前馈计算—计算误差—反向传播—调整权重”的过程，网络中的权重就会被“打磨”得越来越好。那些隐藏层里的神经元，会自发地学会识别一些有用的局部特征，比如胡须、尖耳朵、猫的眼睛轮廓。它们不再是随机的节点，而是变成了名副其实的“特征检测器”。这就是论文标题中“学习表征”的深刻含义。</p>
<p>为了更直观地展示这个过程，我们可以看一段伪代码，它揭示了反向传播在一次迭代中的核心逻辑：</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># 这是一个极简化的伪代码，用于说明反向传播的核心思想</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token comment" style="color:#999988;font-style:italic"># 假设我们有一个简单的三层网络：输入层、一个隐藏层、输出层</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">train_one_epoch</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">network</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> training_data</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> learning_rate</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    total_error </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> y_true </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> training_data</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 1. 前向传播 (Forward Pass)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hidden_inputs </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> network</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">layers</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        output </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> network</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">layers</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">forward</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">hidden_inputs</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 2. 计算误差 (Calculate Error)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        error </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> y_true </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> output</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        total_error </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> error</span><span class="token operator" style="color:#393A34">**</span><span class="token number" style="color:#36acaa">2</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 3. 反向传播 (Backward Pass)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 3a. 计算输出层的梯度</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        output_delta </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> error </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> sigmoid_derivative</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">output</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 3b. 将误差传播到隐藏层</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hidden_error </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> network</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">weights</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">T</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">dot</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">output_delta</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        hidden_delta </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> hidden_error </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> sigmoid_derivative</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">hidden_inputs</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 4. 更新权重 (Update Weights)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 更新隐藏层到输出层的权重</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        network</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">weights</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">1</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> learning_rate </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> np</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">outer</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">output_delta</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> hidden_inputs</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 更新输入层到隐藏层的权重</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        network</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">weights</span><span class="token punctuation" style="color:#393A34">[</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> learning_rate </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> np</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">outer</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">hidden_delta</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> total_error</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>PDP小组的工作是决定性的。他们不仅提供了坚实的数学工具，还出版了两卷本的“连接主义圣经”——《并行分布式处理：认知微观结构的探索》（<em>Parallel Distributed Processing: Explorations in the Microstructure of Cognition</em>）。这本书系统地阐述了连接主义的思想，并用大量的计算机模拟实验，展示了神经网络在语言习得、概念形成、模式识别等多个认知领域的巨大潜力。</p>
<p>这些“顽固派”的工作，终于让连接主义这颗被冰封的种子，在AI的寒冬深处，凭借自身的力量，破土而出，迎来了第一缕解冻的曙光。他们不仅教会了机器如何“知错能改”，更重要的是，他们为未来的深度学习革命，铺设了最关键的一块基石。从此，神经网络不再是那个只能解决“玩具问题”的简单模型，它拥有了学习复杂知识的潜力，只待一个机会，向世界证明它的价值。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="当神经网络第一次有了工作">当神经网络第一次有了“工作”<a href="#当神经网络第一次有了工作" class="hash-link" aria-label="当神经网络第一次有了“工作”的直接链接" title="当神经网络第一次有了“工作”的直接链接">​</a></h2>
<p>反向传播算法的“再发现”，为连接主义者提供了强大的武器，但这件武器在学术圈的轰动，最初并未能迅速转化为工业界的实际应用。对于一个讲求实用和效率的商业世界来说，一个优雅的理论、一个能解决“编码器”问题的实验，都还太过遥远。他们需要看到真金白银——神经网络究竟能做什么“工作”？它能解决什么真实世界的问题？</p>
<p>第一个将这件实验室里的“屠龙之技”带到真实战场，并大获成功的，正是那位在80年代初就独立推导出反向传播思想的法国年轻人——杨立昆（Yann LeCun）。1988年，在多伦多大学完成了博士后研究后，他加入了当时全球最顶尖的工业研究机构之一——美国电话电报公司贝尔实验室（AT&amp;T Bell Labs）。</p>
<p>贝尔实验室给了杨立昆一个极其具体且具有巨大商业价值的挑战：手写数字识别。在那个时代，美国邮政系统每天需要处理数以亿计的邮件，银行需要处理堆积如山的支票，这些单据上的邮政编码和金额大多是手写的。人工录入不仅成本高昂，而且效率低下，错误率高。如果能让机器自动识别这些手写数字，其商业价值不言而喻。</p>
<p>这个问题看似简单，实则异常困难。每个人的笔迹千差万别，数字“7”可能会多一个横杠，“1”可能会有一个弯曲的顶部，“4”的写法更是五花八门。传统的基于规则的图像识别方法，在这种巨大的样式变异性面前捉襟见肘。你无法为所有可能的“5”都写一个规则。</p>
<p>杨立昆敏锐地意识到，这正是神经网络大显身手的舞台。他认为，识别的核心在于提取图像中对身份识别至关重要的“特征”，同时忽略掉那些无关紧要的变体，比如笔画的粗细、倾斜的角度、书写的位置等。他从生物视觉皮层的研究中获得启发——哺乳动物的视觉系统就是通过一系列层级化的细胞来处理视觉信息的，底层的细胞对简单的边缘、角点等做出反应，而更高层的细胞则对更复杂的形状（如面部）做出反应。</p>
<p>基于这个思想，杨立昆设计出了一种专门为处理图像而生的新型神经网络架构，并将其命名为“卷积神经网络”（Convolutional Neural Network, CNN）。CNN的结构与之前简单的全连接网络有几个革命性的不同：</p>
<ol>
<li>
<p><strong>局部感受野（Local Receptive Fields）</strong>：它不像传统网络那样，让每个神经元都连接到输入图像的每一个像素。CNN的神经元只连接到输入图像的一小块局部区域，就像我们的眼睛一次只聚焦于视野的一小部分。这极大地减少了网络的参数数量，也符合图像处理的直观——像素之间的空间关系非常重要。</p>
</li>
<li>
<p><strong>权值共享（Shared Weights）</strong>：CNN的核心思想是，一个用于检测特定特征（比如一个水平边缘）的“滤波器”（在CNN中称为“卷积核”），在图像的左上角有效，那么它在图像的任何其他位置也应该同样有效。因此，在一个特征图中，所有神经元共享同一组权重。这进一步巨幅减少了参数量，并使得网络具有“平移不变性”——无论猫出现在图片的哪个位置，网络都能认出它。</p>
</li>
<li>
<p><strong>下采样（Sub-sampling）</strong>：在卷积层之后，通常会接一个“池化层”（Pooling Layer）。它的作用是对特征图进行压缩，降低其空间分辨率。这不仅能减少计算量，还能提供一定程度的旋转和形变不变性，让网络对一些微小的扰动不那么敏感。</p>
</li>
</ol>
<p>将这几种结构巧妙地组合起来，杨立昆构建了第一个真正意义上的卷积神经网络原型，他将其命名为<strong>LeNet</strong>。LeNet-1在1989年诞生，并在处理美国邮政提供的手写邮编数据集上取得了惊人的成功。</p>
<p>有了初步的成功，杨立昆和他的团队，包括 Léon Bottou、Yoshua Bengio 和 Patrick Haffner，不断对架构进行迭代优化。1998年，他们推出了LeNet家族中最著名、最成熟的版本——<strong>LeNet-5</strong>。这是一个拥有7层的网络，包含两个卷积层、两个下采样层和三个全连接层。它的结构在今天看来依然是所有CNN模型的鼻祖。</p>
<p>LeNet-5的出现，标志着神经网络找到了它的第一份真正意义上的“工作”。AT&amp;T将其商业化，开发出了一套支票自动读取系统。到了90年代末，这套系统已经读取了全美国超过10%的支票，处理了数百万张的交易。这是一个里程碑式的成就。它第一次向世人清晰地证明：连接主义的方法，尤其是经过精心设计的神经网络，不仅在理论上可行，在商业应用上也足以击败所有传统的竞争对手。</p>
<p>LeNet-5的成功，不仅仅在于解决了一个商业问题。它为后来的图像识别、计算机视觉乃至整个深度学习领域，都提供了蓝图和范式。今天我们所熟知的几乎所有成功的图像处理模型，从AlexNet到ResNet，无不带有LeNet的影子。</p>
<p>就在杨立昆让神经网络在银行找到工作的同时，另外两个有趣的应用也在悄然发生，展示了神经网络的通用能力。</p>
<p>一个是在卡内基梅隆大学（CMU），一个名叫<strong>NETtalk</strong>的系统在1987年引起了不小的轰动。这个由特里·塞诺夫斯基（Terry Sejnowski）和查尔斯·罗森博格（Charles Rosenberg）开发的系统，目标是教会计算机朗读英语文本。他们设计了一个简单的三层网络，输入是文本中的一个字母，以及它左右各三个字母的上下文，输出则是控制语音合成器的音素参数。</p>
<p>令人惊讶的是，在经过一夜的训练后，NETtalk从最初发出毫无意义的咿呀乱语，逐渐过渡到能够发出类似婴儿学语的元音和辅音组合，最后竟然能以可以理解的准确度朗读出整个句子。虽然它的发音远非完美，听起来像个口齿不清的孩子，但这个“自己学会说话”的过程，生动地展示了神经网络强大的学习和泛化能力。它不需要语言学家编写任何发音规则，仅从数据中就学会了英语复杂的字母-音素对应关系。</p>
<p>另一个更具未来感的应用同样来自CMU。迪恩·波默洛（Dean Pomerleau）在1989年开发了一个名为<strong>ALVINN</strong>（Autonomous Land Vehicle In a Neural Network）的系统，这是一个早期的自动驾驶项目。波默洛将一个摄像头和一个激光雷达安装在一辆改装过的军用救护车上，车辆的转向控制完全交由一个神经网络决定。</p>
<p>这个网络的输入是摄像头和雷达传来的低分辨率图像，输出则是一个指示方向盘应该转动角度的指令。训练数据来自人类驾驶员的实际操作。当人类驾驶时，系统会记录下当时的道路图像和驾驶员转动方向盘的角度，成对地作为训练样本。经过训练后，ALVINN已经可以在高速公路上以每小时55英里（约88公里）的速度自动行驶。在一次演示中，它成功地在没有人工干预的情况下，自主行驶了近90英里，这在当时是难以想象的成就。</p>
<p>LeNet-5的商业落地、NETtalk的自主发声、ALVINN的自动驾驶，这三份来自不同领域的“工作”，共同构成了神经网络在80年代末到90年代初的“职业生涯初体验”。它们像三颗信号弹，在漫长的AI之冬夜空中升起，向少数仍在坚持的探索者们宣告：寒冬即将过去，一个全新的时代正在酝酿。虽然距离2012年AlexNet引爆深度学习革命还有近二十年的时间，但这些早期开拓性的工作，已经用无可辩驳的实践，证明了连接主义道路的巨大潜力，为即将到来的智能大爆炸备好了所有的燃料。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="gpu的意外之喜cuda改变深度学习的命运">GPU的意外之喜：CUDA改变深度学习的命运<a href="#gpu的意外之喜cuda改变深度学习的命运" class="hash-link" aria-label="GPU的意外之喜：CUDA改变深度学习的命运的直接链接" title="GPU的意外之喜：CUDA改变深度学习的命运的直接链接">​</a></h2>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="当游戏显卡开始不务正业"><strong>当游戏显卡开始“不务正业”</strong><a href="#当游戏显卡开始不务正业" class="hash-link" aria-label="当游戏显卡开始不务正业的直接链接" title="当游戏显卡开始不务正业的直接链接">​</a></h5>
<p>2006年，当黄仁勋（Jensen Huang）在NVIDIA的发布会上意气风发地推出CUDA（Compute Unified Device Architecture）时，他脑海中描绘的未来图景，主要是科学计算、物理模拟和金融建模。这位身穿标志性皮夹克的CEO，希望将NVIDIA的GPU从游戏玩家的专属“装备”，变成科学家和工程师手中的“超级计算机”。他或许没有预料到，自己正在为一个十年后即将席卷全球的产业，无意中铺设了最关键的基石。在当时，人工智能研究，尤其是神经网络，还远不是一个能让NVIDIA高层为之兴奋的词汇。</p>
<p>在此之前，GPU早已是计算机中一个独特的存在。它是一个为大规模并行计算而生的“怪物”。与CPU（Central Processing Unit）那些核心强大、擅长复杂逻辑判断和串行任务的“指挥官”不同，GPU拥有成百上千个小核心，像一支纪律严明的“计算军团”，能够同时对海量数据执行相同的简单操作。这种设计哲学的初衷，是为了高效地完成图形渲染中最繁重的任务：并行处理数百万个顶点和像素。</p>
<p>然而，总有一些“不安分”的极客和科学家，试图让GPU“不务正业”。他们被称为“GPGPU”（General-Purpose computing on GPU）的先驱。在CUDA诞生之前，他们想利用GPU的算力，必须伪装成一个图形渲染任务。他们需要把自己的计算问题（比如流体力学模拟）用图形学的语言（如OpenGL或DirectX的着色器语言）进行包装和欺骗，这个过程极其繁琐和痛苦，堪比戴着镣铐跳舞。</p>
<p>黄仁勋和NVIDIA的远见在于，他们决定亲手砸开这副镣铐。CUDA的发布，意味着开发者终于可以用一种类似于C语言的、更为友好的方式，直接在GPU上编写通用计算程序。NVIDIA为世界打开了一扇通往并行计算新世界的大门，尽管当时大多数人还不知道门后的风景究竟是什么。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="斯坦福地下室传来的福音"><strong>斯坦福地下室传来的福音</strong><a href="#斯坦福地下室传来的福音" class="hash-link" aria-label="斯坦福地下室传来的福音的直接链接" title="斯坦福地下室传来的福音的直接链接">​</a></h5>
<p>真正的转折点发生在2008年的斯坦福大学。当时，吴恩达（Andrew Ng）的团队正在为一个雄心勃勃的项目而苦恼：他们希望构建更大、更深的神经网络，来处理无监督学习任务。但CPU的计算速度成为了一个难以逾越的瓶颈。训练一个像样的模型，往往需要数周甚至数月的时间。</p>
<p>团队中的一位博士生伊恩·巴克（Ian Buck）——他后来成为了NVIDIA CUDA软件的负责人——早已洞察到GPU的潜力。在吴恩达的支持下，另一位研究生拉贾特·雷纳（Rajat Raina）和他的同事们开始尝试将深度信念网络（Deep Belief Networks）的训练过程移植到GPU上。他们发现，神经网络训练的核心，正是大量的矩阵和向量运算。这恰好是GPU的“军团”最擅长的任务。</p>
<p>我们可以用一个简单的伪代码来直观感受这种差异。一个在CPU上执行的矩阵乘法，看起来是这样的：</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># CPU上的矩阵乘法 (概念伪代码)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">matrix_multiply_cpu</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">A</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> B</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  C </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> create_matrix</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">A</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">rows</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> B</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cols</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> i </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> </span><span class="token builtin">range</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">A</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">rows</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> j </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> </span><span class="token builtin">range</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">B</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cols</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token builtin">sum</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> k </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> </span><span class="token builtin">range</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">A</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">cols</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token builtin">sum</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> A</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">k</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> B</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">k</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">j</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      C</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">i</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">[</span><span class="token plain">j</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token builtin">sum</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> C</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>这种嵌套循环的串行方式，效率极低。而在GPU上，借助CUDA，整个计算过程被重新想象：</p>
<div class="language-c++ codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-c++ codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// GPU上的矩阵乘法 (CUDA概念伪代码)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">__global__ void matrix_multiply_gpu(float* A, float* B, float* C, int width) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  // 每个线程负责计算结果矩阵C中的一个元素</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int row = blockIdx.y * blockDim.y + threadIdx.y;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  int col = blockIdx.x * blockDim.x + threadIdx.x;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  float sum = 0;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  for (int k = 0; k &lt; width; ++k) {</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    sum += A[row * width + k] * B[k * width + col];</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  }</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  C[row * width + col] = sum;</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">}</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// 主机代码调用</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">// matrix_multiply_gpu&lt;&lt;&lt;grid_dims, block_dims&gt;&gt;&gt;(dev_A, dev_B, dev_C, width);</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>GPU让成千上万个线程同时启动，每个线程独立计算结果矩阵中的一个元素。这种“同时开火”的并行模式，将计算效率提升了几个数量级。</p>
<p>2009年，雷纳等人在ICML（国际机器学习大会）上发表了他们的论文《使用GPU进行大规模无监督深度学习》。论文的数据令人震惊：在一项任务中，使用一颗价值不到1000美元的NVIDIA GPU，其训练速度是当时顶配多核CPU的70倍。这意味着，原本需要数周才能完成的实验，现在一天之内就能看到结果。</p>
<p>这篇论文如同一声惊雷，唤醒了整个神经网络研究社区。研究人员们终于意识到，他们手中那块用来打《魔兽世界》或《孤岛危机》的显卡，竟然是通往深度学习圣杯的钥匙。NVIDIA也迅速捕捉到了这个信号，开始主动拥抱AI社区，优化CUDA库，推出专门为深度学习设计的硬件和软件。黄仁勋的“无心插柳”，最终成就了深度学习革命中最重要的“柳成荫”。NVIDIA，这家图形芯片公司，戏剧性地成为了人工智能时代的军火商和基础设施之王。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="imagenet的胜利alexnet开启深度学习时代">ImageNet的胜利：AlexNet开启深度学习时代<a href="#imagenet的胜利alexnet开启深度学习时代" class="hash-link" aria-label="ImageNet的胜利：AlexNet开启深度学习时代的直接链接" title="ImageNet的胜利：AlexNet开启深度学习时代的直接链接">​</a></h4>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="一场不公平的对决"><strong>一场“不公平”的对决</strong><a href="#一场不公平的对决" class="hash-link" aria-label="一场不公平的对决的直接链接" title="一场不公平的对决的直接链接">​</a></h5>
<p>2012年的秋天，计算机视觉领域的研究者们像往常一样，聚集在一起，准备揭晓当年的ImageNet大规模视觉识别挑战赛（ILSVRC）的结果。这个比赛被誉为计算机视觉领域的“世界杯”，其难度之大、规模之广，是衡量算法优劣的黄金标准。数据集包含超过120万张高分辨率图像，横跨1000个不同的类别，从“猎豹”到“樱桃”，从“集装箱船”到“摩托车”。</p>
<p>在此之前，这个领域的进展是缓慢而稳健的。主流方法依赖于人工设计的特征提取器，如SIFT（尺度不变特征变换）和HOG（方向梯度直方图），再结合支持向量机（SVM）等分类器进行判断。多年来，各路顶尖团队的最好成绩，其Top-5错误率（即模型给出的前五个最可能的答案中，没有一个是正确答案的概率）一直在26%左右徘徊，每年的进步都以零点几个百分点计。人们普遍认为，这或许就是现有技术的极限。</p>
<p>但2012年的结果公布时，所有人都被惊呆了。一个名不见经传的、名为“SuperVision”的团队，提交了一个名为AlexNet的模型，取得了15.3%的Top-5错误率。当第二名的26.2%被公布时，会场先是死一般的寂静，然后是难以置信的骚动。这已经不是“领先”，而是“碾压”。一场看似实力相当的诸神之战，变成了一场“外星人”对“地球人”的降维打击。</p>
<p>这支“外星人”团队来自多伦多大学，由深度学习的“教父”杰弗里·辛顿和他的两位博士生亚历克斯·克里热夫斯基（Alex Krizhevsky）与伊尔亚·苏茨克维（Ilya Sutskever）组成。他们使用的，正是当时还被许多人视为“炼金术”的深度卷积神经网络（CNN）。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="解构上古神兽alexnet"><strong>解构“上古神兽”AlexNet</strong><a href="#解构上古神兽alexnet" class="hash-link" aria-label="解构上古神兽alexnet的直接链接" title="解构上古神兽alexnet的直接链接">​</a></h5>
<p>AlexNet的胜利并非偶然，它是算法巧思、数据规模和计算暴力完美结合的产物。它的架构在今天看来已是“上古神兽”，但在当时，每一个组件都闪耀着革命性的光芒。</p>
<p>首先，它是一个“深”度网络。AlexNet拥有8个学习层，包括5个卷积层和3个全连接层。这在当时是一个相当庞大的规模，也正是这种深度，赋予了模型从像素中逐层学习抽象特征的能力——从底层的边缘、颜色，到中层的纹理、部件，再到高层的物体概念。</p>
<p>其次，也是最关键的创新之一，是ReLU（Rectified Linear Unit，修正线性单元）激活函数的使用。在此之前，神经网络普遍使用Sigmoid或tanh函数，它们在输入值过大或过小时，梯度会趋近于零，导致“梯度消失”，使得深层网络难以训练。而ReLU的设计简单到极致：<code>f(x) = max(0, x)</code>。当输入为正时，梯度恒为1，这极大地缓解了梯度消失问题，并使得训练速度比传统的Sigmoid网络快了数倍。这个看似微小的改动，却为训练更深的网络打开了大门。</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># ReLU的简单实现</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">relu</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">x</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"> </span><span class="token builtin">max</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> x</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>第三，为了应对拥有6000万个参数的巨大模型可能带来的过拟合问题，他们引入了一种名为“Dropout”的正则化技术。在训练过程中，Dropout会以一定的概率随机地“丢弃”（即暂时禁用）一部分神经元。这就像一个公司在进行项目时，每天都随机让一部分员工休息，从而迫使其他员工必须学会独立、高效地工作，而不能过度依赖某几个“明星员工”。这种方法被证明异常有效，显著提升了模型的泛化能力。</p>
<p>最后，这一切都离不开强大的算力。AlexNet庞大的计算量，远非当时的CPU所能承受。克里热夫斯基用两块NVIDIA GTX 580显卡，通过CUDA编程，花了近一个星期的时间才完成了模型的训练。他甚至巧妙地将网络结构拆分到两块GPU上并行计算，以克服单块显卡3GB显存的限制。这不仅是硬件的胜利，更是软件与硬件协同的典范，直接印证了上一节中GPU带来的革命性力量。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="一声枪响黄金时代开启"><strong>一声枪响，黄金时代开启</strong><a href="#一声枪响黄金时代开启" class="hash-link" aria-label="一声枪响黄金时代开启的直接链接" title="一声枪响黄金时代开启的直接链接">​</a></h5>
<p>AlexNet在ImageNet上的胜利，其意义远远超出了计算机视觉领域。它像一声发令枪，宣告了深度学习黄金时代的开启。</p>
<p>消息传出后，整个科技行业为之震动。那些曾经对深度学习持怀疑态度的大公司，立刻调转船头。2013年3月，谷歌以4400万美元的价格，收购了辛顿和他两名学生创立的初创公司DNNresearch。这三位学者一夜之间成为了谷歌大脑的核心力量。Facebook不甘落后，迅速邀请另一位深度学习巨头杨立昆组建了FAIR（Facebook AI Research）实验室。中国的百度也重金聘请吴恩达，成立了深度学习研究院。</p>
<p>一夜之间，顶级AI人才成为了科技巨头们争抢的稀缺资源。深度学习从一个边缘的学术分支，跃升为科技界最炙手可热的赛道。几乎所有的图像识别、语音识别、自然语言处理任务，都开始被深度学习模型所改写和刷新。AlexNet没有发明卷积神经网络，但它用一场无可辩驳的胜利，向全世界证明了深度学习的强大力量，并彻底改变了人工智能发展的历史进程。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="transformer的革命注意力机制重新定义ai">Transformer的革命：注意力机制重新定义AI<a href="#transformer的革命注意力机制重新定义ai" class="hash-link" aria-label="Transformer的革命：注意力机制重新定义AI的直接链接" title="Transformer的革命：注意力机制重新定义AI的直接链接">​</a></h2>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="rnn的序列魔咒"><strong>RNN的“序列魔咒”</strong><a href="#rnn的序列魔咒" class="hash-link" aria-label="rnn的序列魔咒的直接链接" title="rnn的序列魔咒的直接链接">​</a></h5>
<p>在AlexNet点燃了计算机视觉的革命之火后，人工智能的另一大核心领域——自然语言处理（NLP）——却仍在一种“序列魔咒”的束缚下缓慢前行。这个魔咒的源头，就是循环神经网络（Recurrent Neural Network, RNN）及其变体，如LSTM（长短期记忆网络）和GRU（门控循环单元）。</p>
<p>RNN的设计初衷，是为了处理序列数据。它的核心思想是“循环”：在处理序列中的每一个元素（例如一个单词）时，网络不仅接收当前的输入，还会接收上一个时间步传递过来的“隐藏状态”或“记忆”。这种机制让RNN天然能够捕捉序列中的时序信息。想象一下阅读一个句子：“The cat sat on the mat.” 当RNN读到“mat”时，它的隐藏状态中已经包含了“The cat sat on the”的信息。</p>
<p>这种看似优雅的设计，却隐藏着两个致命的缺陷。第一，它是严格串行的。要处理第十个单词，必须先处理完前九个。这导致RNN无法像CNN那样在GPU上进行大规模并行计算，极大地限制了模型的训练速度和扩展能力。第二，它难以处理长距离依赖。虽然LSTM等变体通过引入精巧的“门”机制来缓解“梯度消失”问题，但当句子变得很长时，网络仍然很难记住开头的信息。比如，在“我出生在法国……我能说一口流利的法语”这个句子里，要正确预测“法语”，模型需要记住开头的“法国”，这对于RNN来说是一个巨大的挑战。</p>
<p>NLP领域的研究者们，就像戴着镣铐的舞者，在RNN的框架内进行着各种精巧的修补，但始终无法打破这个“序列魔咒”。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="注意力不是全部但足够了"><strong>“注意力”不是全部，但足够了</strong><a href="#注意力不是全部但足够了" class="hash-link" aria-label="注意力不是全部但足够了的直接链接" title="注意力不是全部但足够了的直接链接">​</a></h5>
<p>突破的曙光，来自于一个名为“注意力机制”（Attention Mechanism）的理念。2014年，Bahdanau等人在机器翻译任务中首次引入了它。其核心思想很直观：在翻译一个词时，我们不应该只依赖于源语言句子被压缩成的一个固定长度的“记忆向量”，而应该让模型在生成每个目标词时，都能“回头看”源句子的不同部分，并给予不同的“关注度”。这个想法极大地提升了机器翻译的质量，但它仍然是作为RNN架构的一个“辅助插件”存在的。</p>
<p>真正的革命发生在2017年。谷歌大脑的一个团队发表了一篇标题极具宣言色彩的论文——《Attention Is All You Need》。这篇论文提出了一个全新的架构，并给它起了一个同样响亮的名字：Transformer。</p>
<p>作者们的想法大胆到近乎疯狂：既然注意力机制如此有效，我们为什么不干脆扔掉整个RNN结构，只用注意力机制来构建模型呢？他们要彻底砸碎RNN的序列枷锁。</p>
<p>为了实现这个目标，他们设计了一种名为“自注意力”（Self-Attention）的核心模块。与之前在RNN中让目标句关注源句不同，自注意力让句子中的每一个词，都能同时关注到句子中所有其他的词（包括它自己），来计算自身的加权表示。这个过程通过三个向量来完成：查询（Query）、键（Key）和值（Value）。你可以把它想象成一个信息检索过程：每个词都提出一个“查询”（我应该关注谁？），然后与所有词的“键”（我能提供什么信息？）进行匹配打分，最后根据分数对所有词的“值”（我的实际信息）进行加权求和，得到自己新的表示。</p>
<p>这种机制彻底摆脱了序列依赖。句子中任意两个词之间的交互距离都变成了1，长距离依赖问题迎刃而解。更重要的是，整个计算过程是高度可并行化的矩阵运算，完美契合GPU的计算特性。</p>
<p>当然，完全抛弃序列性也带来了新的问题：模型如何知道词语的顺序？为此，论文作者引入了“位置编码”（Positional Encoding），通过一组特殊的、根据位置变化的数学函数（正弦和余弦函数）来为每个输入词向量注入其在序列中的位置信息。</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>sin</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">/</mi><msup><mn>10000</mn><mrow><mn>2</mn><mi>i</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup><mo stretchy="false">)</mo><mspace linebreak="newline"></mspace><mi>P</mi><msub><mi>E</mi><mrow><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mo separator="true">,</mo><mn>2</mn><mi>i</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow></msub><mo>=</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>p</mi><mi>o</mi><mi>s</mi><mi mathvariant="normal">/</mi><msup><mn>10000</mn><mrow><mn>2</mn><mi>i</mi><mi mathvariant="normal">/</mi><msub><mi>d</mi><mtext>model</mtext></msub></mrow></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">PE_{(pos, 2i)} = \sin(pos / 10000^{2i/d_{\text{model}}}) \\
PE_{(pos, 2i+1)} = \cos(pos / 10000^{2i/d_{\text{model}}})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.5198em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em"></span><span class="mop">sin</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">os</span><span class="mord">/1000</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:1.0385em;vertical-align:-0.3552em"></span><span class="mord mathnormal" style="margin-right:0.13889em">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05764em">E</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.5198em;margin-left:-0.0576em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mopen mtight">(</span><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight">os</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mclose mtight">)</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.3552em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1.188em;vertical-align:-0.25em"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathnormal">p</span><span class="mord mathnormal">os</span><span class="mord">/1000</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.938em"><span style="top:-3.113em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span><span class="mord mathnormal mtight">i</span><span class="mord mtight">/</span><span class="mord mtight"><span class="mord mathnormal mtight">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3448em"><span style="top:-2.3488em;margin-left:0em;margin-right:0.0714em"><span class="pstrut" style="height:2.5em"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord text mtight"><span class="mord mtight">model</span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.1512em"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></span>
<p>这就像给每个单词发了一个带有独特频率和相位的“时钟信号”，让模型在没有循环结构的情况下也能感知到语序。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="新范式的基石"><strong>新范式的基石</strong><a href="#新范式的基石" class="hash-link" aria-label="新范式的基石的直接链接" title="新范式的基石的直接链接">​</a></h5>
<p>Transformer的出现，其重要性在当时甚至被一些人低估了。人们最初关注的是它在机器翻译等任务上超越了最好的RNN模型，但它真正的颠覆性在于其架构本身。它为处理序列数据提供了一种全新的、可大规模扩展的范式。</p>
<p>OpenAI的研究人员敏锐地捕捉到了这一点。他们意识到，Transformer的解码器部分（Decoder），其核心就是一种“带掩码的自注意力”（Masked Self-Attention），天然适合进行生成式任务——即根据前面的词来预测下一个词。他们拿掉Transformer的编码器部分，将解码器堆叠起来，用海量的无标签文本数据对其进行训练。</p>
<p>这个看似简单的改造，开启了通往通用人工智能的全新道路。2018年，GPT-1（Generative Pre-trained Transformer）诞生。它证明了基于Transformer的预训练模型，在经过微调后，可以在各种NLP任务上取得优异表现。随后，参数量更大、数据更多的GPT-2和GPT-3接踵而至，它们展现出的强大的文本生成和零样本学习能力，震惊了世界。</p>
<p>从RNN到LSTM，再到带有注意力机制的RNN，这都是在旧范式下的改良。而Transformer，则是对旧范式的彻底颠覆。它用一种非序列化的方式解决了序列问题，为人工智能的“规模化定律”（Scaling Law）——即模型性能随着参数、数据和计算量的增加而可预测地提升——提供了坚实的架构基础。从那一刻起，大语言模型的“大”，才真正成为了可能。Transformer不仅是“你所需要的一切”，它更是我们今天所见证的这场智能觉醒的绝对基石。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="结语三大基石的汇流">结语：三大基石的汇流<a href="#结语三大基石的汇流" class="hash-link" aria-label="结语：三大基石的汇流的直接链接" title="结语：三大基石的汇流的直接链接">​</a></h2>
<p>复盘从2006年到2017年这波澜壮阔的十年，我们不难发现，大语言模型时代的最终降临，并非源于某一次灵光乍现，而是建立在三大关键基石的汇流之上。这三大基石，恰好对应了我们刚刚讲述的三个故事。</p>
<p>第一块基石，是算力的暴力美学。NVIDIA的CUDA平台，将GPU从游戏玩家的娱乐工具，转变为科学计算的利器。它为深度学习提供了此前无法想象的、充裕且经济的计算资源。没有这台强大的“引擎”，任何宏大的模型构想都只能是纸上谈兵。</p>
<p>第二块基石，是深度学习的信念证明。AlexNet在ImageNet上的压倒性胜利，是一场无可辩驳的“加冕仪式”。它用无可争议的实验结果，向整个学术界和工业界宣告：深度学习，尤其是卷积神经网络，是解决复杂模式识别问题的正确道路。这为后续更大规模的模型探索，注入了强大的“信念”。</p>
<p>第三块基石，则是为规模化而生的架构蓝图。Transformer的诞生，彻底打破了RNN的序列化束缚。它提供了一种可无限扩展、可大规模并行、且能完美捕捉长距离依赖的全新范式。这张“蓝图”的出现，才使得参数量从千万级跃升至千亿级，甚至万亿级成为可能。</p>
<p>当引擎（GPU）、信念（AlexNet的胜利）与蓝图（Transformer）齐备，历史的齿轮开始加速转动。通往“巨兽”（Behemoth）级别模型的道路，已经被彻底铺平。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/edit/main/docs/cp1/人工智能的三大范式/神经与连接.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/符号与逻辑"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">符号与逻辑</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">计算与进化</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#当机器开始模仿神经元" class="table-of-contents__link toc-highlight">当机器开始模仿神经元</a></li><li><a href="#明斯基的致命一击与漫长的ai之冬" class="table-of-contents__link toc-highlight">明斯基的致命一击与漫长的AI之冬</a></li><li><a href="#一群顽固派如何教机器知错能改" class="table-of-contents__link toc-highlight">一群“顽固派”如何教机器“知错能改”</a></li><li><a href="#当神经网络第一次有了工作" class="table-of-contents__link toc-highlight">当神经网络第一次有了“工作”</a></li><li><a href="#gpu的意外之喜cuda改变深度学习的命运" class="table-of-contents__link toc-highlight">GPU的意外之喜：CUDA改变深度学习的命运</a></li><li><a href="#transformer的革命注意力机制重新定义ai" class="table-of-contents__link toc-highlight">Transformer的革命：注意力机制重新定义AI</a></li><li><a href="#结语三大基石的汇流" class="table-of-contents__link toc-highlight">结语：三大基石的汇流</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Read</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/intro">Introduction</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub Discussions<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models" target="_blank" rel="noopener noreferrer" class="footer__link-item" remarkplugins="" rehypeplugins="">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Whirling AI Consortium. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>