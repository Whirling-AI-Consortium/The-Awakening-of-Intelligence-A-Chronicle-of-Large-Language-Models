<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-cp1/人工智能的三大范式/计算与进化" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">计算与进化 | 智能的觉醒</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="计算与进化 | 智能的觉醒"><meta data-rh="true" name="description" content="从控制论到强化学习的智能涌现"><meta data-rh="true" property="og:description" content="从控制论到强化学习的智能涌现"><link data-rh="true" rel="icon" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化"><link data-rh="true" rel="alternate" href="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://whirling-ai-consortium.github.io/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化" hreflang="x-default"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.13.24/dist/katex.min.css" integrity="sha384-odtC+0UGzzFL/6PNoE8rX/SPcQDXBJ+uRepguP4QkPCm2LBxH3FA3y+fKSiJ+AmM" crossorigin="anonymous"><link rel="stylesheet" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/assets/css/styles.cd147f59.css">
<script src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/assets/js/runtime~main.31f41e4b.js" defer="defer"></script>
<script src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/assets/js/main.4dee548e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><link rel="preload" as="image" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/logo.svg"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/"><div class="navbar__logo"><img src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/logo.svg" alt="My Book Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/img/logo.svg" alt="My Book Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">主页</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/本书导览">Read Book</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/本书导览">本书导览</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/intro">前言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第一章智能的拂晓">第一章：智能的拂晓</a><button aria-label="折叠侧边栏分类 &#x27;第一章：智能的拂晓&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/前言">前言</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-2 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/人工智能的三大范式">人工智能的三大范式</a><button aria-label="折叠侧边栏分类 &#x27;人工智能的三大范式&#x27;" aria-expanded="true" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/符号与逻辑">符号与逻辑</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接">神经与连接</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-3 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/计算与进化">计算与进化</a></li></ul></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第二章ai江湖-人物与格局">第二章：AI江湖-人物与格局</a><button aria-label="展开侧边栏分类 &#x27;第二章：AI江湖-人物与格局&#x27;" aria-expanded="false" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第一章智能的拂晓"><span itemprop="name">第一章：智能的拂晓</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/人工智能的三大范式"><span itemprop="name">人工智能的三大范式</span></a><meta itemprop="position" content="2"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">计算与进化</span><meta itemprop="position" content="3"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><header><h1>计算与进化</h1></header><p><em>从控制论到强化学习的智能涌现</em></p>
<p>在符号主义者试图于逻辑的殿堂中加冕智能桂冠，而联结主义者在神经元的网络中探寻意识火花的时代，第三条道路已悄然铺开。这条道路的信徒们不向纯粹的理性或大脑的结构寻求启示，而是将目光投向了更古老、更宏大的生命本身——它的互动、适应与进化。他们认为，智能并非诞生于静默的思考，而是涌现于与环境的动态交互之中。这便是行为主义与进化思想的融合，一条从反馈、行动到物竞天择的智能演化之路。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="维纳的控制论反馈回路中的幽灵">维纳的控制论：反馈回路中的幽灵<a href="#维纳的控制论反馈回路中的幽灵" class="hash-link" aria-label="维纳的控制论：反馈回路中的幽灵的直接链接" title="维纳的控制论：反馈回路中的幽灵的直接链接">​</a></h2>
<p>第二次世界大战的阴云笼罩着大西洋，德国空军的轰炸机以越来越高的速度和机动性，向盟军的舰船和地面部队发起致命攻击。在地面上，高射炮手们面临一个几乎无法解决的难题：当你看到敌机时，你瞄准的是它现在的位置，但当炮弹飞行数秒甚至数十秒后，敌机早已飞到了新的位置。如何预测未来？这个问题超越了简单的机械工程，变成了一个关乎信息、预测和控制的数学难题。</p>
<p>这个问题最终被摆在了麻省理工学院（MIT）一位特立独行的天才数学家——诺伯特·维纳（Norbert Wiener）的面前。维纳并非典型的工程师，他是一个博学多才的思考者，其兴趣横跨数学、生物学和哲学。在为军方研究防空火控系统的过程中，维纳意识到，成功的关键不在于制造一门更强大的炮，而在于建立一个更“聪明”的系统。这个系统必须能够：</p>
<ol>
<li><strong>预测（Predict）</strong>：根据飞机过去和现在的轨迹，预测其未来的位置。</li>
<li><strong>行动（Act）</strong>：调整火炮朝向该预测位置开火。</li>
<li><strong>感知（Sense）</strong>：通过雷达等方式观测炮弹的落点与飞机实际位置之间的误差。</li>
<li><strong>修正（Correct）</strong>：将这个“误差”信息作为新的输入，调整下一次的预测和射击。</li>
</ol>
<p>这个“预测-行动-感知-修正”的循环，维纳称之为<strong>反馈（Feedback）</strong>。这在当时是一个革命性的洞见。维纳敏锐地察觉到，这个机制的本质与机器的材质无关，它同样存在于生命系统中。当我们的身体过热时，我们会出汗来降温；当我们感到饥饿时，我们会去寻找食物来补充能量。这些都是生物体为了维持内部稳定（Homeostasis）而进行的负反馈调节。</p>
<p>战争结束后，维纳的思想从军用火控系统这片狭窄的土壤中解放出来，迅速成长为一棵参天大树。1948年，他出版了划时代的著作《控制论：或关于在动物和机器中控制和通信的科学》（Cybernetics: Or Control and Communication in the Animal and the Machine）。“Cybernetics”一词源于希腊语“κυβερνήτης”，意为“舵手”。这精准地概括了其核心思想：智能行为的本质，无论是在生物还是机器中，都是一种通过信息反馈来引导自身、实现目标的“掌舵”过程。</p>
<p>维纳的控制论为智能的实现提供了一种全新的范式。它不再将智能视为一个封闭系统内部的逻辑推理过程，如同符号主义者在“象牙塔”里所做的那样。相反，它认为智能是开放的、动态的，是系统与环境持续互动和自我调节的产物。一个简单的恒温器，通过感知温度变化来控制加热器的开关，虽然简单，却已经具备了控制论智能的雏形。</p>
<p>这一思想迅速在工业界找到了肥沃的土壤。贝尔实验室的克劳DE·香农（Claude Shannon）刚刚发表了他关于信息论的奠基性工作，为“通信”这一控制论的核心概念提供了数学基础。通用电气（General Electric）等公司则在工厂自动化中大量应用伺服机构（servomechanism），这些自动调节的马达和控制器，正是反馈原理的直接体现。它们不需要理解整个生产流程的复杂逻辑，只需要根据设定的目标值和实际的偏差值进行调整，就能精确地完成任务。</p>
<p>控制论的幽灵，那个由反馈回路驱动的智能，开始在20世纪中叶的工厂、导弹和自动化设备中游荡。它没有复杂的知识库，也不模仿神经元的结构，但它通过与世界的直接“对话”——行动与反馈——展现出一种朴素而强大的目的性。它为人工智能的探索打开了第三扇门，门后是一个充满了动态、适应和行为的世界。这条道路的继承者们，将不再满足于让机器仅仅成为一个舵手，他们想让机器像昆虫一样，在真实的世界里自由行走。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="布鲁克斯的昆虫打倒感知-思考-行动的暴政">布鲁克斯的昆虫：打倒“感知-思考-行动”的暴政<a href="#布鲁克斯的昆虫打倒感知-思考-行动的暴政" class="hash-link" aria-label="布鲁克斯的昆虫：打倒“感知-思考-行动”的暴政的直接链接" title="布鲁克斯的昆虫：打倒“感知-思考-行动”的暴政的直接链接">​</a></h2>
<p>时间快进了三十年，来到了1980年代的MIT人工智能实验室。此时，符号主义AI正值其黄金时代的末期，实验室里充斥着庞大而复杂的专家系统和笨重的机器人。这些机器人是其创造者理念的忠实体现，它们遵循着一种被称为“感知-思考-行动”（Sense-Plan-Act）的神圣信条。机器人首先要用各种传感器（感知）来构建一个完整的、精确的世界模型，然后在这个模型上进行复杂的逻辑推理和路径规划（思考），最后才将规划好的指令转化为电机的动作（行动）。</p>
<p>这个过程听起来无懈可击，但在现实中却脆弱得像个笑话。构建一个完美的世界模型几乎不可能，现实世界充满了不确定性和噪声。一个微小的传感器错误，就可能导致整个模型崩溃。更致命的是，“思考”过程极其缓慢。当机器人还在它的中央“大脑”里为“从房间A到房间B”规划出一条完美的数学路径时，一个路过的人或者一把被挪动过的椅子，就足以让整个计划作废。结果就是，这些耗资巨大的机器人常常在原地“思考”良久，然后颤颤巍巍地走上几步，就被现实世界的一个小意外给彻底搞懵了。</p>
<p>就在这片“思考过度”的沉闷空气中，一位来自澳大利亚的年轻教授罗德尼·布鲁克斯（Rodney Brooks）发起了挑战。他看着窗外爬行的蚂蚁，心中充满了困惑。一只蚂蚁的大脑只有大约25万个神经元，它显然没有能力构建一个关于整个花园的精确三维模型，也无法进行复杂的逻辑规划。然而，它却能灵巧地避开障碍、寻找食物、与同伴协作。这说明什么？布鲁克斯得出了一个颠覆性的结论：<strong>智能世界本身就是最好的模型（The world is its own best model）</strong>。</p>
<p>他认为，智能不应该被囚禁在一个中央处理器里进行密集的计算，而应该被分解成一系列与世界直接交互的、简单的行为模块。他将这种激进的新方法命名为<strong>包容架构（Subsumption Architecture）</strong>。</p>
<p>这个名字听起来很学术，但其思想却异常直白。它彻底抛弃了“感知-思考-行动”的集中式流程，代之以一个分层的、分布式的、行为驱动的系统。底层是最基本的生存行为，高层是更复杂的任务导向行为。每一层都是一个独立的“感知-行动”回路，并且高层可以“包容”（subsume）或抑制低层的行为。</p>
<p>让我们以布鲁克斯建造的第一个真正意义上的“昆虫”机器人——六条腿的“成吉思”（Genghis）为例，来理解这个架构。</p>
<div class="codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-text codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain">// Genghis行为分层的伪代码示意</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Layer 0: 站立 (当腿部传感器感到触地时，保持不动)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; IF leg_contact == TRUE, THEN motor_stop().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Layer 1: 向前行走 (当没有更高层指令时，交替摆动六条腿)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; UNLESS higher_layer_active, THEN execute_walk_gait().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; Layer 1 *包容* Layer 0 的静止行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Layer 2: 避障 (当前方触须传感器碰到物体时，后退并转向)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; IF whisker_sensor == OBSTACLE, THEN stop_walk(), move_backward(), turn_randomly().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; Layer 2 的避障行为 *包容* Layer 1 的行走行为。</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">Layer 3: 追踪红外信标 (当红外传感器探测到信号时，转向并朝信号方向前进)</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; IF IR_sensor == DETECTED, THEN turn_towards_IR(), move_forward().</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    -&gt; Layer 3 的追踪行为 *包容* Layer 2 的随机避障和 Layer 1 的常规行走。</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>成吉思没有中央大脑，没有世界地图，也没有复杂的行动规划器。它的“智能”分布在这些简单的、并行的行为层级中。当它被启动时，它首先尝试行走（Layer 1）。如果前方的触须碰到了墙壁，避障模块（Layer 2）立即被激活，它会抑制“行走”指令，取而代之执行“后退转向”的动作。一旦障碍消失，Layer 2不再活跃，控制权就交还给Layer 1，机器人继续行走。整个过程流畅、快速且极其鲁棒。它不是在“思考”如何走路，它<strong>就是</strong>在走路。</p>
<p>布鲁克斯的昆虫机器人，如成吉思和后来的艾伦（Allen），在当时昂贵而笨拙的机器人世界里，显得既廉价又高效。它们向整个AI界宣告：智能可以不是自上而下精心设计的产物，而是自下而上简单行为涌现的结果。这种思想直接影响了后来的火星车“旅居者号”（Sojourner）的部分行为控制系统，也为现代机器人学和行为AI奠定了基础。</p>
<p>布鲁克斯的革命，本质上是对智能根源的一场“政变”。他将智能从中央处理器的“王座”上推翻，将其释放到传感器和执行器的每一个角落，让它在与物理世界的每一次亲密接触中获得生命。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="遗传算法的达尔文主义当代码开始优胜劣汰">遗传算法的达尔文主义：当代码开始优胜劣汰<a href="#遗传算法的达尔文主义当代码开始优胜劣汰" class="hash-link" aria-label="遗传算法的达尔文主义：当代码开始优胜劣汰的直接链接" title="遗传算法的达尔文主义：当代码开始优胜劣汰的直接链接">​</a></h2>
<p>如果说布鲁克斯是从生物个体的行为中获得了灵感，那么另一位思想家则将目光投向了更为宏大的生命图景——物种的演化。在密歇根大学，一位名叫约翰·霍兰德（John Holland）的学者，正沉浸在查尔斯·达尔文《物种起源》带来的震撼中。他思考的不是如何让一个机器人模仿昆虫，而是如何让计算机程序本身像生命一样，经历自然选择，自我进化。</p>
<p>1960年代，计算机科学的主流是逻辑和确定性。程序员像上帝一样，精确地设计算法的每一步，以求得到一个唯一、正确的答案。但霍兰德看到，自然界解决问题的方式截然不同。自然界没有一个顶层设计师，它通过“变异”和“选择”这两个简单粗暴的机制，在数百万年的时间里，“创造”出了从细菌到人类这样极其复杂的生命体。面对复杂问题，大自然的方法是：<strong>尝试足够多的可能性，然后让最好的活下来</strong>。</p>
<p>这个想法在当时的计算机界听起来近乎疯狂，但霍兰德却坚信，可以将其转化为一种强大的计算范式。他将这个想法系统化，并命名为<strong>遗传算法（Genetic Algorithm, GA）</strong>。</p>
<p>遗传算法的核心，是将达尔文的进化论三部曲——<strong>繁殖（Reproduction）</strong>、<strong>交叉（Crossover）和变异（Mutation）</strong>——进行了一次优雅的计算机模拟。这个过程的目标，不是为了创造生命，而是为了找到复杂问题的最优解。</p>
<p>想象一下，我们要解决一个工程难题，比如设计一个兼具强度和轻量化的桥梁结构。可能的结构组合有无数种。用传统方法逐一计算评估，无异于大海捞针。而遗传算法的流程则完全不同：</p>
<ol>
<li>
<p><strong>编码（Encoding）</strong>：首先，需要一种方式来描述一个“解”。我们可以将桥梁的各项参数（如横梁的长度、材料、角度等）编码成一串数字或二进制位，这就像生物的基因染色体（Chromosome）。
<code>Solution_A = [1.25, &#x27;steel&#x27;, 30.5, ...]</code> -&gt; <code>Chromosome_A = &quot;01101001...&quot;</code></p>
</li>
<li>
<p><strong>初始化种群（Initialization）</strong>：随机生成一大批（比如1000个）不同的“染色体”，每一个都代表一种桥梁设计方案。这个初始种群（Population）可能充满了各种糟糕、荒谬的设计，但这没关系，进化需要从混沌开始。</p>
</li>
<li>
<p><strong>适应度评估（Fitness Evaluation）</strong>：接下来，需要一个“裁判”。我们定义一个适应度函数（Fitness Function），它可以根据桥梁设计的强度、重量、成本等指标，给每一个“染色体”打分。分数越高的，代表设计越“优良”。</p>
</li>
<li>
<p><strong>选择（Selection）</strong>：这是“优胜劣汰”的开始。在种群中，适应度分数高的个体（优秀设计）将有更高的概率被选中，进入“繁殖”阶段。而分数低的个体，则更有可能被淘汰。这模拟了自然界中，更适应环境的生物更容易存活并繁衍后代。</p>
</li>
<li>
<p><strong>交叉与变异（Crossover &amp; Mutation）</strong>：这是创造新一代的关键。</p>
<ul>
<li><strong>交叉</strong>：从被选中的“父母”中，随机挑选两个，将它们的“染色体”进行部分交换和重组，生成新的“子代”染色体。这就像生物的有性繁殖，子代会继承父母双方的部分优良基因。
<code>Parent_A = [1111]0000</code>
<code>Parent_B = [0000]1111</code>
<code>Offspring = [1111]1111</code>  (交换后半部分)</li>
<li><strong>变异</strong>：在生成子代的过程中，以一个极小的概率，随机改变“染色体”上的某个基因位（比如将0变为1）。这模拟了生物遗传中的基因突变，它是产生全新性状、跳出局部最优解的希望所在。</li>
</ul>
</li>
</ol>
<p>通过不断重复“评估-选择-交叉-变异”这个循环，整个种群的平均适应度会一代一代地提高。经过数百上千代的“进化”，最终种群中会涌现出那些我们用传统设计方法很难想到的、性能优异的桥梁设计方案。</p>
<p>霍兰德在1975年出版的《自然与人工系统中的适应》（Adaptation in Natural and Artificial Systems）一书中，为遗传算法奠定了坚实的理论基础。起初，这一思想在学术界备受冷遇，因为它看起来太“不科学”了——它依赖于随机和概率，无法保证找到绝对的最优解，也无法解释为什么某个解是好的。你得到的只是一个结果，而非一个清晰的推导过程。</p>
<p>然而，在工程、金融和物流等领域，人们关心的往往不是“为什么”，而是“是什么”。遗传算法在解决那些变量极多、关系极其复杂的优化问题上，展现出了惊人的威力。从天线的设计、芯片的布线，到投资组合的优化、生产排程的规划，这种“让代码自己进化”的方法，成为工程师们工具箱里的一件秘密武器。</p>
<p>约翰·霍兰德的遗传算法，与维纳的控制论、布鲁克斯的包容架构一样，都属于一个更广泛的家族——<strong>自适应系统</strong>。它们共同揭示了一个深刻的道理：智能不一定需要一个全知全能的中央大脑。通过反馈、交互、试错和选择，简单的底层规则足以在复杂的环境中涌现出高级、鲁棒且高效的智能行为。这条道路的终点，将在数十年后与神经网络的浪潮汇合，共同孕育出真正震撼世界的成果——强化学习。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="强化学习的觉醒从td-gammon到alphago">强化学习的觉醒：从TD-Gammon到AlphaGo<a href="#强化学习的觉醒从td-gammon到alphago" class="hash-link" aria-label="强化学习的觉醒：从TD-Gammon到AlphaGo的直接链接" title="强化学习的觉醒：从TD-Gammon到AlphaGo的直接链接">​</a></h2>
<p>1992年，IBM的托马斯·J·沃森研究中心里，一位名叫杰拉德·特索罗（Gerald Tesauro）的研究员正在做一件在外人看来有些“不务正业”的事情。他没有在研究大型机或者数据库，而是在教一台计算机下西洋双陆棋（Backgammon）。这在当时并不是什么新鲜事，用计算机下棋的程序早已存在，它们大多基于庞大的开局库和专家们手工编写的评估函数，本质上是符号主义思想的延伸——将人类的棋类知识编码成机器可执行的规则。</p>
<p>但特索罗的方法完全不同。他使用的，是一种在学术界被讨论了十几年但从未在如此复杂的问题上证明过自己的技术——强化学习（Reinforcement Learning, RL），特别是理查德·萨顿（Richard Sutton）等人提出的时序差分学习（Temporal-Difference Learning, TD-Learning）。</p>
<p>强化学习的思想根植于最古老的行为主义心理学：一个智能体（agent）在一个环境（environment）中，它会观察到当前的状态（state），并尝试做出一个动作（action）。环境会根据这个动作给予一个奖励（reward）或惩罚，并进入下一个状态。智能体的目标，就是学会一套策略（policy），来最大化它在未来能获得的累计奖励。这就像训练一只宠物，它做对了就给零食，做错了就口头制止，久而久之，它就学会了什么能做、什么不能做。</p>
<p>早期的强化学习受困于“维度灾难”——在西洋双陆棋这样拥有高达 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>20</mn></msup></mrow><annotation encoding="application/x-tex">10^{20}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">20</span></span></span></span></span></span></span></span></span></span></span></span> 种可能局面的游戏中，为每一个状态记录其价值是完全不可行的。特索罗的突破在于，他将神经网络与时序差分学习巧妙地结合了起来。他用一个简单的多层感知器（MLP）作为函数逼近器（function approximator）：网络的输入是棋盘的布局，输出则是一个单一的数值，代表当前局面对己方获胜概率的评估。</p>
<p>他把这个程序命名为 <strong>TD-Gammon</strong>。起初，特索罗用一个包含专家知识的数据集对网络进行监督学习，使其达到一个不错的业余水平。但接下来，他做出了一个让整个AI界都为之震惊的决定：他让程序彻底抛弃人类知识，只通过“自我对弈”来学习。</p>
<p>特索罗设置了两套完全相同的TD-Gammon程序互为对手。它们从随机的权重开始，下出完全随机、毫无章法的棋。一盘棋结束后，获胜方会得到一个+1的奖励，落败方则是-1。关键在于棋局过程中的学习。在每一步棋后，程序会根据下一步棋的局面评估值来更新当前步的评估值。这就是TD学习的核心——用“后见之明”来修正“先见之明”。其更新规则可以简化为这样一个公式：</p>
<span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>←</mo><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo>+</mo><mi>α</mi><mo stretchy="false">[</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>γ</mi><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo>−</mo><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">V(s_t) \leftarrow V(s_t) + \alpha [R_{t+1} + \gamma V(s_{t+1}) - V(s_t)]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2778em"></span><span class="mrel">←</span><span class="mspace" style="margin-right:0.2778em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.0037em">α</span><span class="mopen">[</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">γV</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)]</span></span></span></span></span>
<p>其中，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 是对当前状态价值的估计， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">R_{t+1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8917em;vertical-align:-0.2083em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span></span></span></span> 是下一步获得的即时奖励， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s_{t+1})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 是对下一个状态价值的估计。这个公式的精髓在于，它用 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>R</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>+</mo><mi>γ</mi><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mrow><mi>t</mi><mo>+</mo><mn>1</mn></mrow></msub><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R_{t+1} + \gamma V(s_{t+1}))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">γV</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em"><span></span></span></span></span></span></span><span class="mclose">))</span></span></span></span> 这个更准确的“目标值”来校准当前的估计 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>V</mi><mo stretchy="false">(</mo><msub><mi>s</mi><mi>t</mi></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">V(s_t)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.22222em">V</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2806em"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">t</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 。通过海量的自我对弈，神经网络的权重在反向传播算法的驱动下，不断朝着更准确地预测最终胜负的方向进行微调。</p>
<p>TD-Gammon在IBM的计算机上不间断地左右互搏。经过几天、几周、几个月，奇迹发生了。这个从零开始的程序，水平以肉眼可见的速度提高。在进行了超过150万局自我对弈后，TD-Gammon已经进化成了一个可怕的对手。特索罗邀请了当时世界上最顶尖的西洋双陆棋大师，如Bill Robertie和Paul Magriel，与TD-Gammon对弈。结果令所有专家大跌眼镜：TD-Gammon不仅能与人类冠军分庭抗礼，甚至在某些对局中展现出了超越人类的、全新的战略思想。它的一些开局走法，在人类几百年的双陆棋历史中从未出现过，但事后被顶尖棋手分析认为是“具有开创性的、正确的下法”。</p>
<p>TD-Gammon的成功是一座沉默的里程碑。它第一次向世界证明，一个复杂的、曾经被认为是人类智慧和经验结晶的领域，可以被一个几乎没有先验知识、仅靠自我试错和学习的系统所征服。它揭示了强化学习与神经网络结合的巨大潜力。然而，在当时，连接主义的第二次浪潮尚未完全到来，算力的限制和算法的脆弱性使得TD-Gammon的成功更像是一个难以复制的“孤例”。在接下来的近二十年里，强化学习更多地停留在学术圈，应用在机器人控制、资源调度等相对小众的领域，静静地等待着下一次爆发的催化剂。</p>
<p>这个催化剂在21世纪的第二个十年到来了，它的名字叫“深度学习”。而将深度学习的强大感知能力与强化学习的决策能力完美融合的“梦之队”，是一家成立于2010年、名为DeepMind的英国初创公司。公司的创始人，杰米斯·哈萨比斯（Demis Hassabis）、沙恩·列格（Shane Legg）和穆斯塔法·苏莱曼（Mustafa Suleyman），从一开始就抱着一个宏伟的目标：”Solve intelligence“（解决智能）。</p>
<p>2013年，DeepMind的研究员们，在后来的AlphaGo项目负责人大卫·席尔瓦（David Silver）的带领下，将目光投向了另一个充满童年回忆的领域——雅达利（Atari）2600游戏机。他们想解决一个比TD-Gammon更根本的问题：机器能否像人类一样，仅仅通过观察屏幕像素，就学会玩各种不同的电子游戏？</p>
<p>他们提出的解决方案，后来在2015年以一篇封面文章的形式发表在《自然》上，其名声响彻云霄——<strong>深度Q网络（Deep Q-Network, DQN）</strong>。DQN是TD-Gammon思想的极致升华。它用一个深度的卷积神经网络（CNN）来代替TD-Gammon中的浅层MLP。CNN强大的图像特征提取能力，使得DQN可以直接处理原始的像素数据，而不需要任何人工设计的特征。这意味着，同一个DQN架构，可以被应用在《太空侵略者》、《打砖块》、《拳击》等数十种规则迥异的游戏上，实现了通用性的巨大飞跃。</p>
<p>为了解决训练过程中的不稳定性，DeepMind引入了两项关键技术：<strong>经验回放（Experience Replay）和目标网络（Target Network）</strong>。经验回放机制将智能体经历过的转换（状态、动作、奖励、下一状态）存储在一个巨大的“记忆库”中，训练时随机从中抽取小批量样本进行学习，打破了数据之间的时间相关性，使训练更稳定。目标网络则是复制一个主网络的副本，用于计算TD目标值，并定期同步主网络的权重，这大大缓解了Q值估计中的震荡和发散问题。</p>
<p>DQN的成功让整个AI界为之振奋。2014年，尚在DQN论文发表之前，谷歌便以超过5亿美元的天价收购了DeepMind。哈萨比斯和他的团队获得了几乎无限的资源和计算能力，去挑战那个被誉为“人类智慧最后一块高地”的古老游戏——围棋。</p>
<p>围棋的复杂度远非西洋双陆棋可比。其状态空间复杂度约为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>10</mn><mn>170</mn></msup></mrow><annotation encoding="application/x-tex">10^{170}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em"></span><span class="mord">1</span><span class="mord"><span class="mord">0</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em"><span style="top:-3.063em;margin-right:0.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">170</span></span></span></span></span></span></span></span></span></span></span></span>，比可观测宇宙中的原子总数还要多。传统的搜索算法，如象棋程序“深蓝”使用的Alpha-Beta剪枝，在这里完全无效，因为围棋的分支因子（每一步的可能性）太宽，评估函数也极难设计。</p>
<p>DeepMind的解决方案，<strong>AlphaGo</strong>，是一个集大成的工程奇迹。它不再是单一的神经网络，而是一个由多个核心部件协同工作的复杂系统：</p>
<ol>
<li>
<p><strong>策略网络（Policy Network）</strong>：这是一个13层的CNN，它的任务是“观察”当前棋盘的局面（输入），然后“预测”出最有可能是高手会下的几个落子点（输出）。这个网络通过学习数百万局人类高手的棋谱进行监督学习训练，使其初步具备了高手的“棋感”。</p>
</li>
<li>
<p><strong>价值网络（Value Network）</strong>：这也是一个CNN，但它的任务不是选择落子点，而是对当前局面进行“打分”，评估黑棋或白棋的最终胜率。它的训练数据，来自于AlphaGo的自我对弈。</p>
</li>
<li>
<p><strong>蒙特卡洛树搜索（Monte Carlo Tree Search, MCTS）</strong>：这是AlphaGo决策的“大脑中枢”。MCTS不像传统搜索算法那样穷尽所有可能，而是像一位经验丰富的棋手一样，进行选择性的“推演”。策略网络会告诉MCTS哪些分支“值得一看”，从而极大地收窄搜索宽度。在推演到一定深度后，价值网络会对叶子节点的局面进行快速评估，从而避免了将棋局下到底。MCTS通过在策略网络和价值网络的指导下进行数千次数万次的模拟，最终选择那个在模拟中胜率最高的落子点。</p>
</li>
</ol>
<p>2016年3月，韩国首尔，AlphaGo与世界围棋冠军李世石的“人机大战”吸引了全球的目光。全世界数亿人通过直播观看了这场比赛。结果是颠覆性的：AlphaGo以4比1的总比分击败了这位拥有14个世界冠军头衔的人类传奇。</p>
<p>在第二局比赛的第37手，AlphaGo下出了一步令所有职业棋手都感到困惑、甚至认为是“臭棋”的落子。这步棋完全超出了人类数千年围棋经验所能理解的范畴。然而，随着棋局的推进，这步看似无理的棋子却发挥了至关重要的作用，奠定了AlphaGo的胜局。欧洲围棋冠军樊麾在现场解说道：“这不是人类的棋，这是神的棋。”这一手，后来被称为“神之一手”（The Move of God），它成为了AI创造力超越人类的象征性时刻。</p>
<p>AlphaGo的胜利，宣告了强化学习时代的真正来临。它不再是实验室里的玩具，而是能够解决世界上最复杂策略问题的强大工具。从TD-Gammon的孤独探索，到DQN的通用游戏技巧，再到AlphaGo在人类智慧之巅的加冕，强化学习走过了一条从边缘到中心、从觉醒到君临的漫长道路。它所代表的通过与环境交互进行学习的思想，已经成为构建通用人工智能不可或缺的核心支柱之一。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="多智能体系统群体智能的涌现现象">多智能体系统：群体智能的涌现现象<a href="#多智能体系统群体智能的涌现现象" class="hash-link" aria-label="多智能体系统：群体智能的涌现现象的直接链接" title="多智能体系统：群体智能的涌现现象的直接链接">​</a></h2>
<p>在人工智能的宏大叙事中，我们常常聚焦于创造一个单一的、超级智能的“大脑”，无论是深蓝、沃森还是AlphaGo，它们都是中心化的智能体。然而，自然界提供了另一种截然不同的智能范本：没有指挥官的蚁群如何找到最短路径？没有领头鸟的鸟群如何保持优雅的队形？没有中枢神经的细胞如何协作形成复杂的器官？</p>
<p>这些现象背后指向了一种迷人的可能性：复杂的、全局性的智能行为，可以从大量简单的、遵循局部规则的个体（智能体）的交互中<strong>涌现</strong>（emerge）出来。这就是多智能体系统（Multi-Agent Systems, MAS）和群体智能（Swarm Intelligence）研究的核心思想，一条通往智能的“自下而上”的道路。</p>
<p>这条道路的早期开拓者之一是计算机图形学领域的克雷格·雷诺兹（Craig Reynolds）。1986年，他在思考如何用计算机模拟逼真的鸟群飞行。他发现，试图为整个鸟群设计一个中心化的控制算法是极其困难且不自然的。于是，他转换了思路：如果我不是鸟群的“上帝”，而只是其中一只普通的“鸟”（他称之为<strong>Boid</strong>），我需要遵守哪些简单的规则才能不掉队、不撞上同伴？</p>
<p>雷诺兹提出了三个惊人简单的局部规则：</p>
<ol>
<li><strong>分离（Separation）</strong>：避免与附近的同伴发生碰撞。</li>
<li><strong>对齐（Alignment）</strong>：将自己的飞行方向调整为附近同伴的平均方向。</li>
<li><strong>聚集（Cohesion）</strong>：朝附近同伴的平均位置移动，以保持群体的凝聚力。</li>
</ol>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="color:#393A34;background-color:#f6f8fa"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token comment" style="color:#999988;font-style:italic"># Boids算法核心思想的伪代码表示</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">class</span><span class="token plain"> </span><span class="token class-name">Boid</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">__init__</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">self</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> position</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> velocity</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">velocity </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token keyword" style="color:#00009f">def</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">update</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">self</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> all_boids</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        neighbors </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">get_neighbors</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">all_boids</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">not</span><span class="token plain"> neighbors</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token keyword" style="color:#00009f">return</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 1. 分离：计算一个远离邻居的向量</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        separation_vector </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> Vector</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> other </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> neighbors</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            </span><span class="token keyword" style="color:#00009f">if</span><span class="token plain"> distance</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> other</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">&lt;</span><span class="token plain"> MIN_DISTANCE</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">                separation_vector </span><span class="token operator" style="color:#393A34">-=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">other</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 2. 对齐：计算邻居的平均速度</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        alignment_vector </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> Vector</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> other </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> neighbors</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            alignment_vector </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> other</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">velocity</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        alignment_vector </span><span class="token operator" style="color:#393A34">/=</span><span class="token plain"> </span><span class="token builtin">len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">neighbors</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 3. 聚集：计算去往邻居中心的向量</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cohesion_vector </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> Vector</span><span class="token punctuation" style="color:#393A34">(</span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token number" style="color:#36acaa">0</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token keyword" style="color:#00009f">for</span><span class="token plain"> other </span><span class="token keyword" style="color:#00009f">in</span><span class="token plain"> neighbors</span><span class="token punctuation" style="color:#393A34">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">            cohesion_vector </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> other</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cohesion_vector </span><span class="token operator" style="color:#393A34">/=</span><span class="token plain"> </span><span class="token builtin">len</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">neighbors</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        cohesion_vector </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> cohesion_vector </span><span class="token operator" style="color:#393A34">-</span><span class="token plain"> self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token comment" style="color:#999988;font-style:italic"># 将三个规则的力结合，更新自己的速度和位置</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">velocity </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> separation_vector </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> W1 </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> alignment_vector </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> W2 </span><span class="token operator" style="color:#393A34">+</span><span class="token plain"> cohesion_vector </span><span class="token operator" style="color:#393A34">*</span><span class="token plain"> W3</span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">position </span><span class="token operator" style="color:#393A34">+=</span><span class="token plain"> self</span><span class="token punctuation" style="color:#393A34">.</span><span class="token plain">velocity</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>当成百上千个Boid在计算机屏幕上同时遵循这三条规则时，奇迹发生了。它们自发地形成了极其逼真、流畅变化的鸟群形态，能够优雅地绕开障碍物，分裂成小组，然后再重新汇合。没有任何一个Boid知道整个鸟群的形状，也没有任何中央指挥官，但宏观的、有序的群体行为却从中涌现。雷诺兹的Boids程序不仅为后来的电影特效（如《蝙蝠侠归来》中的蝙蝠群）和电子游戏提供了基础，更重要的是，它生动地展示了“涌现”这一概念的强大力量。</p>
<p>如果说Boids是群体智能在行为模拟上的体现，那么另一项源于昆虫世界的研究则将其引入了复杂的优化领域。1992年，比利时学者马可·多里戈（Marco Dorigo）在他的博士论文中提出了<strong>蚁群优化算法（Ant Colony Optimization, ACO）</strong>。</p>
<p>多里戈的灵感来自于对真实蚂蚁觅食行为的观察。蚂蚁如何在没有任何地图的情况下，找到从蚁巢到食物源的最短路径？答案在于一种名为“信息素”（Pheromone）的化学物质。蚂蚁在爬行时会沿途释放信息素，并且它们倾向于选择信息素浓度更高的路径。这就形成了一个正反馈循环：</p>
<ol>
<li>最初，蚂蚁随机探索。</li>
<li>通往食物源的路径有多条，走的路径越短，蚂蚁往返一次的时间就越短。</li>
<li>单位时间内，在短路径上往返的蚂蚁更多，因此短路径上信息素的累积速度也更快。</li>
<li>更高的信息素浓度会吸引更多的蚂蚁选择这条路径，从而进一步加强该路径上的信息素。</li>
</ol>
<p>多里戈将这个过程抽象成了一个解决组合优化问题（如旅行商问题，TSP）的算法。在算法中，“蚂蚁”是虚拟的智能体，它们在问题的解空间（如图的各个节点）中移动，构建解决方案（一条路径）。它们所释放的“信息素”是一个存储在计算机内存中的矩阵，记录了路径上各个边的“受欢迎程度”。一个“蚂T蚁”在选择下一个城市时，会综合考虑两个因素：一是两个城市间的距离（启发式信息），二是连接两个城市的路径上的信息素浓度。</p>
<p>通过一代又一代的“蚂蚁”不断地构建路径和释放信息素，算法最终能够收敛到接近最优的解决方案。蚁群算法的优美之处在于它的分布式和协作性。每个蚂蚁都是一个简单的计算单元，它们之间没有直接通信，而是通过修改共享的环境（信息素矩阵）来进行间接通信，这种方式被称为“Stigmergy”（共识主动性）。</p>
<p>这些关于复杂系统和涌现现象的研究，在美国新墨西哥州的一个思想高地——**圣塔菲研究所（Santa Fe Institute, SFI）**找到了它们的智识家园。SFI成立于1984年，由一批顶尖的物理学家（包括诺奖得主默里·盖尔曼）、经济学家和计算机科学家共同创立。它是一个跨学科的天堂，致力于研究那些贯穿于物理、生物、经济和社会系统中的普适性规律，而“复杂适应性系统”（Complex Adaptive Systems, CAS）正是其核心理念。</p>
<p>在SFI的视野中，无论是蚁群、免疫系统、城市还是股票市场，都可以被看作是由大量相互作用的、能够学习和适应的智能体组成的系统。这些系统的宏观行为（如市场崩盘、城市扩张）往往是不可预测的，并且不能简单地通过分析单个组成部分来理解。遗传算法的先驱约翰·霍兰德（John Holland）也是SFI的核心成员，他的工作与多智能体系统的思想异曲同工，都强调了自下而上的适应和进化过程。</p>
<p>群体智能的思想如今已经渗透到现代AI系统的各个角落。在物流领域，它被用于优化成千上万辆货车的配送路线。在通信领域，它被用于设计动态的、鲁棒性强的无线传感器网络路由协议。在机器人领域，它更是大放异彩：美国宾夕法尼亚大学的Vijay Kumar实验室和后来被Uber收购的KMel Robotics公司，展示了由数十架甚至上百架无人机组成的编队，如何像Boids一样协同飞行，完成复杂的建造和表演任务。它们没有中心控制器，每架无人机都根据邻近无人机的位置和速度 autonomously 调整自己的行为，共同完成搭建桥梁、穿越窄门等惊人壮举。</p>
<p>从雷诺兹的Boids，到多里戈的蚁群，再到圣塔菲研究所的宏大理论框架，最后到今天天空中飞舞的无人机集群，多智能体系统为我们描绘了一幅与“超级大脑”截然不同的智能图景。它告诉我们，智能不必是孤独和集中的，它也可以是分布式的、协作的和涌现的。在未来，当我们需要设计能够适应复杂动态环境的、具有高度鲁棒性和可扩展性的AI系统时——无论是管理智慧城市的交通流，还是协调战场上的机器人军团——这种源于群体、归于群体的智能范式，无疑将扮演越来越重要的角色。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="小结行动涌现与自下而上的智能">小结：行动、涌现与自下而上的智能<a href="#小结行动涌现与自下而上的智能" class="hash-link" aria-label="小结：行动、涌现与自下而上的智能的直接链接" title="小结：行动、涌现与自下而上的智能的直接链接">​</a></h2>
<p>当我们回顾第三章所描绘的这条漫长而曲折的探索之路——从维纳控制论的反馈回路，到布鲁克斯机器昆虫的蹒跚学步，再到霍兰德遗传算法的数字进化，最终在强化学习的自我对弈与多智能体系统的群体涌现中达到高潮——我们实际上是在审视人工智能的第三种宏大范式。如果说符号主义试图构建一个逻辑严密的“思想王国”，连接主义致力于复刻一个精巧的“仿生大脑”，那么本章所探讨的，无疑是一部关于“行动与演化”的史诗。</p>
<p>这一范式的核心，不再是静态的知识表征或被动的模式识别，而是智能体（Agent）与环境之间持续不断的、动态的交互。它回答了一个根本性的问题：不依赖于人类预先编写的详尽规则，智能如何从最基本的“试错”中自发地生长出来？</p>
<p>我们看到，这个问题的答案在半个多世纪里以多种形态呈现。在控制论的早期，它是防空火控系统中那个简单的“测量-校正”反馈循环，是智能最朴素的雏形。在罗德尼·布鲁克斯的包容架构中，它化身为一个个独立的、类似昆虫本能的行为层，简单的“避障”和“前行”指令叠加，竟能涌现出复杂的导航能力，这是对符号主义“思考-感知-行动”中心化模型的第一次有力反叛。</p>
<p>随后，约翰·霍兰德的遗传算法将视角拉得更为宏大，将达尔文的“物竞天择”引入了算法世界。在这里，环境化身为一个无情的“适应度函数”，优秀的解决方案（编码的染色体）得以生存和繁衍，通过交叉与变异，在广阔的解空间中“进化”出人类难以直接设计的答案。这是一种不依赖梯度的、更为全局和鲁棒的优化哲学。</p>
<p>而这条交互与学习的道路，最终在强化学习中找到了最耀眼的出口。从TD-Gammon在西洋双陆棋盘上超越人类的深邃策略，到AlphaGo在围棋“神之一手”中展现的惊人创造力，我们见证了单一智能体通过最大化未来奖励的简单目标，学习到了何等复杂的策略。它证明，一个足够强大的学习机制（如深度神经网络）配上一个足够丰富的交互环境（如自我对弈），足以征服人类智慧的顶峰。</p>
<p>最后，多智能体系统则将这一范式推向了终极的分布式形态。无论是雷诺兹的Boids还是多里戈的蚁群，它们都揭示了一个更为深刻的真理：宏大的、全局的秩序与智能，并不一定需要一个中心化的“大脑”。它可以从大量遵循简单局部规则的个体交互中“涌现”出来。智能，可以是一种集体现象。</p>
<p>这些技术、发现所串联起的，是一条“自下而上”的智能探索路径。它始于对简单反馈的控制，发展为对个体行为的模拟，升华为对种群演化的借鉴，最终在单个体与环境的深度学习和多体间的群体协作中开花结果。这一范式的演进，为人工智能提供了不同于逻辑和感知的第三条腿——行动的能力。正是这种在与世界互动中学习和适应的能力，使得AI能够走出数字世界，真正进入物理现实，为机器人、自动驾驶、以及未来更复杂的分布式智能系统的实现奠定了不可或缺的基石。</p></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="row margin-top--sm theme-doc-footer-edit-meta-row"><div class="col"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/edit/main/docs/cp1/人工智能的三大范式/计算与进化.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div><div class="col lastUpdated_JAkA"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/cp1/人工智能的三大范式/神经与连接"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">神经与连接</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/category/第二章ai江湖-人物与格局"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">第二章：AI江湖-人物与格局</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#维纳的控制论反馈回路中的幽灵" class="table-of-contents__link toc-highlight">维纳的控制论：反馈回路中的幽灵</a></li><li><a href="#布鲁克斯的昆虫打倒感知-思考-行动的暴政" class="table-of-contents__link toc-highlight">布鲁克斯的昆虫：打倒“感知-思考-行动”的暴政</a></li><li><a href="#遗传算法的达尔文主义当代码开始优胜劣汰" class="table-of-contents__link toc-highlight">遗传算法的达尔文主义：当代码开始优胜劣汰</a></li><li><a href="#强化学习的觉醒从td-gammon到alphago" class="table-of-contents__link toc-highlight">强化学习的觉醒：从TD-Gammon到AlphaGo</a></li><li><a href="#多智能体系统群体智能的涌现现象" class="table-of-contents__link toc-highlight">多智能体系统：群体智能的涌现现象</a></li><li><a href="#小结行动涌现与自下而上的智能" class="table-of-contents__link toc-highlight">小结：行动、涌现与自下而上的智能</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Read</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/docs/intro">Introduction</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models/discussions" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub Discussions<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/whirling-ai-consortium/The-Awakening-of-Intelligence-A-Chronicle-of-Large-Language-Models" target="_blank" rel="noopener noreferrer" class="footer__link-item" remarkplugins="" rehypeplugins="">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2025 Whirling AI Consortium. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>